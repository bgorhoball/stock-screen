"""
Notification module for VCP screening results.
Supports Slack, Discord, email, and GitHub integrations.
"""

import requests
import json
import logging
import os
from typing import Dict, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class NotificationSender:
    """Handles sending notifications through various channels."""

    def __init__(self):
        self.slack_webhook = os.getenv('SLACK_WEBHOOK_URL')
        self.discord_webhook = os.getenv('DISCORD_WEBHOOK_URL')

    def send_slack_notification(self, summary: Dict, top_matches: List[Dict]) -> bool:
        """
        Send VCP screening results to Slack.

        Args:
            summary: Screening summary statistics
            top_matches: List of top VCP matches

        Returns:
            True if notification sent successfully
        """
        if not self.slack_webhook:
            logger.warning("No Slack webhook URL configured")
            return False

        try:
            # Prepare emoji indicators
            emoji = "🎯" if summary['vcp_patterns_detected'] > 0 else "📊"
            confidence_emoji = "🔥" if summary['high_confidence_matches'] > 0 else "⚡"

            # Build message blocks
            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"{emoji} VCP Screening Results - {summary['scan_date'].split()[0]}"
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Symbols Scanned:* {summary['total_symbols_scanned']}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*VCP Patterns:* {summary['vcp_patterns_detected']}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*{confidence_emoji} High Confidence:* {summary['high_confidence_matches']}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*📈 Breakouts:* {summary['breakouts_detected']}"
                        }
                    ]
                }
            ]

            # Add top matches if any
            if top_matches:
                match_text = ""
                for match in top_matches[:5]:  # Top 5 matches
                    confidence_stars = "⭐" * min(3, int(match['confidence'] * 3))
                    breakout_indicator = "🚀" if match.get('breakout_detected', False) else "⏳"
                    match_text += f"{breakout_indicator} *{match['symbol']}* - {confidence_stars} ({match['confidence']:.2f})\n"

                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Top Matches:*\n{match_text}"
                    }
                })

            # Add footer
            blocks.append({
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": f"Execution time: {summary['execution_time_seconds']}s | Generated by VCP Bot 🤖"
                    }
                ]
            })

            payload = {
                "text": f"VCP Screening Results - {summary['vcp_patterns_detected']} patterns detected",
                "blocks": blocks
            }

            response = requests.post(self.slack_webhook, json=payload, timeout=30)
            response.raise_for_status()

            logger.info("Slack notification sent successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")
            return False

    def send_discord_notification(self, summary: Dict, top_matches: List[Dict]) -> bool:
        """
        Send VCP screening results to Discord.

        Args:
            summary: Screening summary statistics
            top_matches: List of top VCP matches

        Returns:
            True if notification sent successfully
        """
        if not self.discord_webhook:
            logger.warning("No Discord webhook URL configured")
            return False

        try:
            # Prepare embed color based on results
            color = 0x00ff00 if summary['vcp_patterns_detected'] > 0 else 0x808080  # Green or gray

            # Build embed
            embed = {
                "title": f"📊 VCP Screening Results - {summary['scan_date'].split()[0]}",
                "color": color,
                "fields": [
                    {
                        "name": "📈 Summary",
                        "value": (
                            f"**Symbols Scanned:** {summary['total_symbols_scanned']}\n"
                            f"**VCP Patterns:** {summary['vcp_patterns_detected']}\n"
                            f"**High Confidence:** {summary['high_confidence_matches']}\n"
                            f"**Breakouts:** {summary['breakouts_detected']}"
                        ),
                        "inline": True
                    },
                    {
                        "name": "⚡ Performance",
                        "value": (
                            f"**Detection Rate:** {summary['vcp_detection_rate']}%\n"
                            f"**Execution Time:** {summary['execution_time_seconds']}s\n"
                            f"**Data Quality:** {summary['avg_data_points_per_symbol']:.0f} avg points"
                        ),
                        "inline": True
                    }
                ],
                "footer": {
                    "text": "Generated by VCP Screening Bot 🤖"
                },
                "timestamp": datetime.utcnow().isoformat()
            }

            # Add top matches
            if top_matches:
                matches_text = ""
                for i, match in enumerate(top_matches[:5]):
                    breakout_indicator = "🚀" if match.get('breakout_detected', False) else "⏳"
                    matches_text += f"{i+1}. {breakout_indicator} **{match['symbol']}** - {match['confidence']:.2f}\n"

                embed["fields"].append({
                    "name": "🎯 Top Matches",
                    "value": matches_text or "No matches today",
                    "inline": False
                })

            payload = {
                "embeds": [embed]
            }

            response = requests.post(self.discord_webhook, json=payload, timeout=30)
            response.raise_for_status()

            logger.info("Discord notification sent successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to send Discord notification: {e}")
            return False

    def create_email_content(self, summary: Dict, top_matches: List[Dict]) -> str:
        """
        Create HTML email content for VCP screening results.

        Args:
            summary: Screening summary statistics
            top_matches: List of top VCP matches

        Returns:
            HTML email content
        """
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>VCP Screening Results</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f0f8ff; padding: 20px; border-radius: 8px; }}
                .summary {{ background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 20px 0; }}
                .matches {{ margin: 20px 0; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                .high-confidence {{ background-color: #e8f5e8; }}
                .medium-confidence {{ background-color: #fff8dc; }}
                .footer {{ color: #666; font-size: 12px; margin-top: 30px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>📊 VCP Screening Results</h1>
                <h2>{summary['scan_date'].split()[0]}</h2>
            </div>

            <div class="summary">
                <h3>Summary Statistics</h3>
                <ul>
                    <li><strong>Symbols Scanned:</strong> {summary['total_symbols_scanned']}</li>
                    <li><strong>VCP Patterns Detected:</strong> {summary['vcp_patterns_detected']}</li>
                    <li><strong>High Confidence Matches:</strong> {summary['high_confidence_matches']}</li>
                    <li><strong>Medium Confidence Matches:</strong> {summary['medium_confidence_matches']}</li>
                    <li><strong>Breakouts Detected:</strong> {summary['breakouts_detected']}</li>
                    <li><strong>Detection Rate:</strong> {summary['vcp_detection_rate']}%</li>
                    <li><strong>Execution Time:</strong> {summary['execution_time_seconds']} seconds</li>
                </ul>
            </div>
        """

        if top_matches:
            html_content += """
            <div class="matches">
                <h3>🎯 Top VCP Matches</h3>
                <table>
                    <tr>
                        <th>Symbol</th>
                        <th>Confidence</th>
                        <th>Contractions</th>
                        <th>Base Length (Days)</th>
                        <th>Volume Trend</th>
                        <th>Breakout</th>
                    </tr>
            """

            for match in top_matches[:10]:
                confidence_class = "high-confidence" if match['confidence'] >= 0.8 else "medium-confidence"
                breakout_text = "✅ Yes" if match.get('breakout_detected', False) else "⏳ Pending"

                html_content += f"""
                    <tr class="{confidence_class}">
                        <td><strong>{match['symbol']}</strong></td>
                        <td>{match['confidence']:.2f}</td>
                        <td>{match['contractions_count']}</td>
                        <td>{match['base_length_days']}</td>
                        <td>{match['volume_trend']}</td>
                        <td>{breakout_text}</td>
                    </tr>
                """

            html_content += """
                </table>
            </div>
            """
        else:
            html_content += """
            <div class="matches">
                <h3>No VCP patterns detected today</h3>
                <p>The screening did not identify any stocks meeting the VCP criteria today. This is normal and part of the market cycle.</p>
            </div>
            """

        html_content += f"""
            <div class="footer">
                <p>This report was generated automatically by the VCP Screening Bot 🤖</p>
                <p>For more information about VCP patterns, refer to Mark Minervini's methodology.</p>
            </div>
        </body>
        </html>
        """

        return html_content

    def send_notifications(self, summary: Dict, top_matches: List[Dict]) -> Dict[str, bool]:
        """
        Send notifications through all configured channels.

        Args:
            summary: Screening summary statistics
            top_matches: List of top VCP matches

        Returns:
            Dictionary indicating success/failure for each channel
        """
        results = {}

        # Send Slack notification
        if self.slack_webhook:
            results['slack'] = self.send_slack_notification(summary, top_matches)

        # Send Discord notification
        if self.discord_webhook:
            results['discord'] = self.send_discord_notification(summary, top_matches)

        # Log results
        successful_channels = [channel for channel, success in results.items() if success]
        failed_channels = [channel for channel, success in results.items() if not success]

        if successful_channels:
            logger.info(f"Notifications sent successfully to: {', '.join(successful_channels)}")

        if failed_channels:
            logger.warning(f"Failed to send notifications to: {', '.join(failed_channels)}")

        return results


if __name__ == "__main__":
    # Test notifications with sample data
    logging.basicConfig(level=logging.INFO)

    sample_summary = {
        'scan_date': '2024-01-15 18:30:00',
        'total_symbols_scanned': 503,
        'vcp_patterns_detected': 3,
        'high_confidence_matches': 1,
        'medium_confidence_matches': 2,
        'breakouts_detected': 1,
        'vcp_detection_rate': 0.6,
        'execution_time_seconds': 145.2
    }

    sample_matches = [
        {
            'symbol': 'AAPL',
            'confidence': 0.85,
            'contractions_count': 3,
            'base_length_days': 42,
            'volume_trend': 'decreasing',
            'breakout_detected': True
        },
        {
            'symbol': 'MSFT',
            'confidence': 0.72,
            'contractions_count': 2,
            'base_length_days': 28,
            'volume_trend': 'stable',
            'breakout_detected': False
        }
    ]

    sender = NotificationSender()

    # Test email content generation
    email_content = sender.create_email_content(sample_summary, sample_matches)
    print("Email content generated successfully")

    # Test notifications (will only work if webhooks are configured)
    results = sender.send_notifications(sample_summary, sample_matches)
    print(f"Notification results: {results}")